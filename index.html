<!DOCTYPE html>
<html>
<head>
    <title>Jogo do Problema de Transporte</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #gameCanvas { border: 1px solid black; }
        #message { font-size: 24px; font-weight: bold; margin-top: 10px; }
        #instructions {
            font-size: 18px;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        #distances {
            margin-top: 20px;
            font-size: 18px;
        }
        #legend {
            margin-top: 20px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <h1>Jogo do Problema de Transporte</h1>
    <div id="instructions">
        <p>Imagine que você é o gerente da cadeia de suprimentos da MóveisDesign, a marca de móveis mais bem-sucedida do país. Você é responsável por gerenciar cada etapa do processo, desde a obtenção das matérias-primas até a entrega dos móveis finalizados nas lojas.</p>
        <p>Você tem vários fornecedores de madeira, cada um com preços diferentes e quantidades máximas diferentes, e precisa entregar essa madeira para várias fábricas de móveis, cada uma com uma capacidade máxima e custo de produção diferente.</p>
        <p>Para atender à demanda de móveis no mercado, qual seria a melhor combinação de fornecedores de madeira com as fábricas, de modo a minimizar o custo total, cobrindo toda a demanda?</p>
        <p>Os nós vermelhos são os <strong>fornecedores</strong> e os nós verdes são as <strong>fábricas</strong>.</p>
        <p>Clique com o botão esquerdo do mouse em cima de cada fornecedor e indique a quantidade de produto que deverá sair desse fornecedor, clique em OK e em seguida clique para qual fábrica deverá ser enviada aquela quantidade.</p>
        <p>Para saber a resposta ótima, clique ao final com o botão direito do mouse.</p>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="message"></div>
    <div id="legend">
        <p><span style="color: blue;">─</span> Alocações do Usuário</p>
        <p><span style="color: yellow; border-bottom: 1px dashed;">─</span> Alocações Ótimas</p>
    </div>
    <div id="distances"></div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageDiv = document.getElementById('message');
        const distancesDiv = document.getElementById('distances');

        const WIDTH = 800;
        const HEIGHT = 600;
        const numSuppliers = 3;
        const numConsumers = 3;
        const minDistance = 50;

        let suppliers = [];
        let consumers = [];
        let transportCosts = [];
        let allocations = [];
        let message = '';
        let optimalAllocations = [];
        let optimalCost = 0;
        let showOptimal = false;

        // Function to draw points on the canvas
        function drawPointsAndText() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);

            // Draw allocations
            for (let [supplier, consumer, quantity] of allocations) {
                if (consumer) {
                    ctx.beginPath();
                    ctx.moveTo(supplier.x, supplier.y);
                    ctx.lineTo(consumer.x, consumer.y);
                    ctx.strokeStyle = 'blue';
                    ctx.stroke();
                    ctx.fillStyle = 'black';
                    ctx.fillText(quantity, (supplier.x + consumer.x) / 2, (supplier.y + consumer.y) / 2);
                }
            }

            if (showOptimal) {
                // Draw optimal allocations
                for (let [supplier, consumer, quantity] of optimalAllocations) {
                    if (quantity > 0) {
                        ctx.beginPath();
                        ctx.setLineDash([5, 5]); // Dashed line
                        ctx.moveTo(supplier.x, supplier.y);
                        ctx.lineTo(consumer.x, consumer.y);
                        ctx.strokeStyle = 'yellow';
                        ctx.stroke();
                        ctx.setLineDash([]); // Reset line dash
                        ctx.fillStyle = 'black';
                        ctx.fillText(quantity, (supplier.x + consumer.x) / 2, (supplier.y + consumer.y) / 2);
                    }
                }
            }

            // Draw suppliers
            for (let supplier of suppliers) {
                ctx.beginPath();
                ctx.arc(supplier.x, supplier.y, 10, 0, 2 * Math.PI);
                ctx.fillStyle = 'red';
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.fillText(`Fornecedor ${supplier.index + 1}`, supplier.x - 15, supplier.y - 15);
                ctx.fillText(`Oferta: ${supplier.supply}`, supplier.x + 15, supplier.y);
            }

            // Draw consumers
            for (let consumer of consumers) {
                ctx.beginPath();
                ctx.arc(consumer.x, consumer.y, 10, 0, 2 * Math.PI);
                ctx.fillStyle = 'green';
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.fillText(`Fábrica ${consumer.index + 1}`, consumer.x - 15, consumer.y - 15);
                ctx.fillText(`Demanda: ${consumer.demand}`, consumer.x + 15, consumer.y);
            }

            // Draw total cost text
            const totalCost = calculateTotalCost(allocations);
            ctx.fillStyle = 'black';
            ctx.font = '24px Arial';
            ctx.fillText(`Custo Total: ${totalCost}`, 10, 30);

            // Display message
            if (message) {
                messageDiv.textContent = message;
                messageDiv.style.display = 'block';
            } else {
                messageDiv.textContent = '';
                messageDiv.style.display = 'none';
            }

            // Display distances
            displayDistances();
        }

        // Function to calculate total cost
        function calculateTotalCost(allocations) {
            let totalCost = 0;
            for (let [supplier, consumer, quantity] of allocations) {
                if (consumer) {
                    totalCost += quantity * transportCosts[supplier.index][consumer.index];
                }
            }
            return Math.round(totalCost);
        }

        // Function to find the optimal solution using MODI method
        function findOptimalSolution() {
            let remainingSupply = suppliers.map(s => s.supply);
            let remainingDemand = consumers.map(c => c.demand);
            let minCost = 0;
            let bestAllocations = [];

            for (let i = 0; i < numSuppliers; i++) {
                for (let j = 0; j < numConsumers; j++) {
                    if (remainingSupply[i] > 0 && remainingDemand[j] > 0) {
                        let quantity = Math.min(remainingSupply[i], remainingDemand[j]);
                        bestAllocations.push([suppliers[i], consumers[j], quantity]);
                        remainingSupply[i] -= quantity;
                        remainingDemand[j] -= quantity;
                        minCost += quantity * transportCosts[i][j];
                    }
                }
            }

            // Applying MODI method to optimize the initial solution
            let u = new Array(numSuppliers).fill(null);
            let v = new Array(numConsumers).fill(null);
            u[0] = 0;

            while (true) {
                let improvements = false;

                // Calculate potentials
                for (let [s, c, q] of bestAllocations) {
                    if (u[s.index] !== null) {
                        v[c.index] = transportCosts[s.index][c.index] - u[s.index];
                    } else if (v[c.index] !== null) {
                        u[s.index] = transportCosts[s.index][c.index] - v[c.index];
                    }
                }

                // Check for optimality
                let entering = null;
                let maxReduction = 0;
                for (let i = 0; i < numSuppliers; i++) {
                    for (let j = 0; j < numConsumers; j++) {
                        if (!bestAllocations.some(([s, c]) => s.index === i && c.index === j)) {
                            let cost = transportCosts[i][j];
                            let reduction = cost - (u[i] + v[j]);
                            if (reduction < maxReduction) {
                                maxReduction = reduction;
                                entering = [i, j];
                                improvements = true;
                            }
                        }
                    }
                }

                if (!improvements) break;

                // Update the allocations (simplified for this example)
                let [ei, ej] = entering;
                let delta = Math.min(remainingSupply[ei], remainingDemand[ej]);
                remainingSupply[ei] -= delta;
                remainingDemand[ej] -= delta;
                bestAllocations.push([suppliers[ei], consumers[ej], delta]);

                minCost += delta * transportCosts[ei][ej];
            }

            return { bestAllocations, minCost: Math.round(minCost) };
        }

        // Function to display distances
        function displayDistances() {
            distancesDiv.innerHTML = '<h3>Distâncias:</h3>';
            let table = '<table border="1" cellpadding="5" cellspacing="0">';
            table += '<tr><th></th>';
            for (let j = 0; j < numConsumers; j++) {
                table += `<th>Fábrica ${j + 1}</th>`;
            }
            table += '</tr>';
            for (let i = 0; i < numSuppliers; i++) {
                table += `<tr><th>Fornecedor ${i + 1}</th>`;
                for (let j = 0; j < numConsumers; j++) {
                    table += `<td>${transportCosts[i][j]}</td>`;
                }
                table += '</tr>';
            }
            table += '</table>';
            distancesDiv.innerHTML += table;
        }

        // Mouse click event
        canvas.addEventListener('mousedown', (event) => {
            const x = event.offsetX;
            const y = event.offsetY;

            if (event.button === 0) { // Left click
                for (let supplier of suppliers) {
                    if (Math.hypot(supplier.x - x, supplier.y - y) < 15) {
                        let currentAllocated = allocations
                            .filter(allocation => allocation[0] === supplier)
                            .reduce((sum, allocation) => sum + allocation[2], 0);
                        let remainingSupply = supplier.supply - currentAllocated;
                        let quantity = prompt(`Digite a quantidade a ser transportada deste fornecedor (máximo ${remainingSupply}):`);
                        quantity = parseInt(quantity);
                        if (!isNaN(quantity) && quantity > 0 && quantity <= remainingSupply) {
                            allocations.push([supplier, null, quantity]);
                            drawPointsAndText();
                        } else {
                            alert(`Quantidade inválida. Por favor, insira um número entre 1 e ${remainingSupply}.`);
                        }
                        return;
                    }
                }

                for (let consumer of consumers) {
                    if (Math.hypot(consumer.x - x, consumer.y - y) < 15) {
                        for (let allocation of allocations) {
                            if (allocation[1] === null) {
                                allocation[1] = consumer;
                                drawPointsAndText();
                                return;
                            }
                        }
                    }
                }
            } else if (event.button === 2) { // Right click
                const { bestAllocations, minCost } = findOptimalSolution();
                const userCost = calculateTotalCost(allocations);

                if (userCost === minCost) {
                    message = 'Parabéns! Você encontrou a solução ótima.';
                    messageDiv.style.color = 'green';
                    optimalAllocations = allocations;
                } else {
                    message = `Dessa vez não! O custo ótimo é ${minCost}.`;
                    messageDiv.style.color = 'red';
                    optimalAllocations = bestAllocations;
                }

                showOptimal = true;
                drawPointsAndText();
            }
        });

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (event) => event.preventDefault());

        // Function to check if the distance between points is acceptable
        function isDistanceAcceptable(newPoint, existingPoints, minDistance) {
            for (let point of existingPoints) {
                if (Math.hypot(newPoint.x - point.x, newPoint.y - point.y) < minDistance) {
                    return false;
                }
            }
            return true;
        }

        // Function to generate points with minimum distance
        function generatePoints(numPoints, minDistance) {
            let points = [];
            while (points.length < numPoints) {
                let newPoint = {
                    x: Math.random() * (WIDTH - 100) + 50,
                    y: Math.random() * (HEIGHT - 100) + 50
                };
                if (isDistanceAcceptable(newPoint, points, minDistance)) {
                    points.push(newPoint);
                }
            }
            return points;
        }

        // Function to initialize the game
        function initGame() {
            let supplierPoints = generatePoints(numSuppliers, minDistance);
            let consumerPoints = generatePoints(numConsumers, minDistance);

            suppliers = supplierPoints.map((point, index) => ({
                ...point,
                supply: Math.floor(Math.random() * 50) + 20,
                index: index
            }));

            consumers = consumerPoints.map((point, index) => ({
                ...point,
                demand: Math.floor(Math.random() * 50) + 20,
                index: index
            }));

            transportCosts = suppliers.map(supplier => 
                consumers.map(consumer => 
                    Math.round(Math.hypot(supplier.x - consumer.x, supplier.y - consumer.y))
                )
            );

            allocations = [];
            optimalAllocations = [];
            message = '';
            showOptimal = false;

            drawPointsAndText();
        }

        // Initialize the game
        initGame();
    </script>
</body>
</html>
